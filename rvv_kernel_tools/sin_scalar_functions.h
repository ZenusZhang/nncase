#pragma once

#include <cmath>
#include <cstring>
#include <cstdint>

// Generated by convert_rvv_to_scalar.py
// Scalar versions of RISC-V vector sin implementation for precision analysis

struct SinDebugValues {
    double input_v; // Original input value
    double r_abs; // Absolute value of input
    double n_unrounded; // Unrounded k value (|x|/pi)
    int32_t ki; // Rounded integer k
    double n_rounded; // k converted back to float/double
    uint32_t sign_bits; // Sign extraction bits
    uint32_t odd_bits; // Odd quadrant adjustment bits
    uint32_t final_sign_bits; // Final sign bits after odd adjustment
    double r_reduced; // Range reduced value (|x| - k*pi)
    double r_prime; // Transformed argument (pi/2 - r)
    double r2; // r_prime squared
    double y_c12; // After c12 coefficient
    double y_c10; // After c10 coefficient
    double y_c8; // After c8 coefficient
    double y_c6; // After c6 coefficient
    double y_c4; // After c4 coefficient
    double y_c2; // After c2 coefficient
    double poly_result; // Final polynomial result (c0)
    double final_result_before_sign; // Result before sign application
    double final_result; // Final result with sign applied
};

SinDebugValues sin_scalar_f32_debug(float v) {
    SinDebugValues dbg = {};
    dbg.input_v = v;

    // Variable declarations
    float r, n;
    int32_t ki;
    uint32_t sign, odd;
    float r2, y;

    // Converted operations
    r = std::fabs(v); // /* r = |x| and capture sign from input */                                       auto r = __riscv_vfabs_v_f32m##lmul(v, vl)
    sign = __riscv_vreinterpret_v_f32m##lmul##_i32m##lmul(v) ^ __riscv_vreinterpret_v_f32m##lmul##_i32m##lmul(r); // auto sign = __riscv_vxor_vv_i32m##lmul(                                             __riscv_vreinterpret_v_f32m##lmul##_i32m##lmul(v),                              __riscv_vreinterpret_v_f32m##lmul##_i32m##lmul(r), vl)
    n = r * 0x1.45f306p-2f; // /* k = round(|x|/pi) */                                                        auto n = __riscv_vfmul_vf_f32m##lmul(r, 0x1.45f306p-2f, vl)
    ki = static_cast<int32_t>(roundf(n)); // auto ki = __riscv_vfcvt_x_f_v_i32m##lmul(n, vl)
    n = static_cast<float>(ki); // n = __riscv_vfcvt_f_x_v_f32m##lmul(ki, vl)
    odd = ki & 1; // /* odd = ((k & 1) << 31), merge into sign early */                              auto odd = __riscv_vand_vx_i32m##lmul(ki, 1, vl)
    odd = odd << 31; // odd = __riscv_vsll_vx_i32m##lmul(odd, 31, vl)
    sign = sign ^ odd; // sign = __riscv_vxor_vv_i32m##lmul(sign, odd, vl)
    r = r - 0x1.921fb6p+1f * n; // /* r = |x| - k*pi (3-term high-precision split) */                              r = __riscv_vfnmsac_vf_f32m##lmul(r,  0x1.921fb6p+1f, n, vl)
    r = r - -0x1.777a5cp-24f * n; // r = __riscv_vfnmsac_vf_f32m##lmul(r, -0x1.777a5cp-24f, n, vl)
    r = r - -0x1.ee59dap-49f * n; // r = __riscv_vfnmsac_vf_f32m##lmul(r, -0x1.ee59dap-49f, n, vl)
    r = 0x1.921fb6p+0f - r; // /* r' = pi/2 - r using 3-term split to reduce cancellation error */             /* pi/2 split: +0x1.921fb6p+0f, -0x1.777a5cp-25f, -0x1.ee59dap-50f */           r = __riscv_vfrsub_vf_f32m##lmul(r,  0x1.921fb6p+0f, vl)
    r = r + -0x1.777a5cp-25f; // r = __riscv_vfadd_vf_f32m##lmul(r, -0x1.777a5cp-25f, vl)
    r = r + -0x1.ee59dap-50f; // r = __riscv_vfadd_vf_f32m##lmul(r, -0x1.ee59dap-50f, vl)
    r2 = r * r; // /* r2 = r'^2 */                                                                 auto r2 = __riscv_vfmul_vv_f32m##lmul(r, r, vl)

    return dbg;
}

SinDebugValues sin_scalar_f64_debug(double v) {
    SinDebugValues dbg = {};
    dbg.input_v = v;

    // Variable declarations
    double r, n;
    int32_t ki;
    uint32_t sign, odd;
    double r2, y;

    // Converted operations
    r = std::fabs(v); // /* r = |x| and capture sign from input */                                       auto r = __riscv_vfabs_v_f32m##lmul(v, vl)
    sign = __riscv_vreinterpret_v_f32m##lmul##_i32m##lmul(v) ^ __riscv_vreinterpret_v_f32m##lmul##_i32m##lmul(r); // auto sign = __riscv_vxor_vv_i32m##lmul(                                             __riscv_vreinterpret_v_f32m##lmul##_i32m##lmul(v),                              __riscv_vreinterpret_v_f32m##lmul##_i32m##lmul(r), vl)
    n = r * 1.0 / M_PI; // /* k = round(|x|/pi) */                                                        auto n = __riscv_vfmul_vf_f32m##lmul(r, 0x1.45f306p-2f, vl)
    ki = static_cast<int32_t>(roundf(n)); // auto ki = __riscv_vfcvt_x_f_v_i32m##lmul(n, vl)
    n = static_cast<float>(ki); // n = __riscv_vfcvt_f_x_v_f32m##lmul(ki, vl)
    odd = ki & 1; // /* odd = ((k & 1) << 31), merge into sign early */                              auto odd = __riscv_vand_vx_i32m##lmul(ki, 1, vl)
    odd = odd << 31; // odd = __riscv_vsll_vx_i32m##lmul(odd, 31, vl)
    sign = sign ^ odd; // sign = __riscv_vxor_vv_i32m##lmul(sign, odd, vl)
    r = r - 3.1415926218032837 * n; // /* r = |x| - k*pi (3-term high-precision split) */                              r = __riscv_vfnmsac_vf_f32m##lmul(r,  0x1.921fb6p+1f, n, vl)
    r = r - -3.1786509424591713e-08 * n; // r = __riscv_vfnmsac_vf_f32m##lmul(r, -0x1.777a5cp-24f, n, vl)
    r = r - -1.2246467991473532e-16 * n; // r = __riscv_vfnmsac_vf_f32m##lmul(r, -0x1.ee59dap-49f, n, vl)
    r = 1.5707963267948966 - r; // /* r' = pi/2 - r using 3-term split to reduce cancellation error */             /* pi/2 split: +0x1.921fb6p+0f, -0x1.777a5cp-25f, -0x1.ee59dap-50f */           r = __riscv_vfrsub_vf_f32m##lmul(r,  0x1.921fb6p+0f, vl)
    r = r + -6.123233995736766e-17; // r = __riscv_vfadd_vf_f32m##lmul(r, -0x1.777a5cp-25f, vl)
    r = r + -3.061616997868383e-17; // r = __riscv_vfadd_vf_f32m##lmul(r, -0x1.ee59dap-50f, vl)
    r2 = r * r; // /* r2 = r'^2 */                                                                 auto r2 = __riscv_vfmul_vv_f32m##lmul(r, r, vl)

    return dbg;
}

